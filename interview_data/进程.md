**进程：**用户程序在运行的时候需要的是一个简单的环境，就好像自己**占用**了整个计算机的资源一样（独立的地址空间和 CPU）。

**地址空间**可以理解为一个数组每个元素都是一个门牌号，数组的长度取决于 CPU 能够寻址到的大小。总线是 32 位（一个机器时钟内 CPU 可以处理 32位的二进制数据）的地址空间大小为 ````2^32 = 4294967296```` 即为 4GB。
地址空间分为俩类，虚拟和物理的空间。物理的地址空间可以理解为物理内存的大小，但是实际中安装的内存比能寻址到的要小的话，那么超出的那些寻址空间都是无效的。虚拟空间就代表当前用户程序所属的一段假想出来的空间，然后系统会处理虚拟空间和物理空间的映射，这样可以做到进程间的隔离同时也提高了用户程序直接使用物理空间被黑客串改的难度。

但是这样任然会有3个问题：
1. 不同的用户程序的地址要彼此隔离
2. 当内存不足访问后续的用户程序的时候，需要把现存的程序数据存入磁盘然后再把新的用户程序导入内存中，这样就会有内存的使用效率问题
3. 用户程序载入的时候的内存地址不是固定的，都要给它分配一块足够大的区域，但是用户程序代码编写的访问数据和跳转指令的地址是固定的，这样就会带来麻烦。

**分段**的方法可以解决第 1 和 3 个问题，由系统或者软件通过一个映射的函数来映射虚拟地址空间到物理地址空间，当程序实际运行的时候 CPU 会把虚拟地址通过这个映射函数转化后去访问。这样的好处可以让不同的用户程序隔离。并且用户程序只需要关心自己的虚拟地址，无论最终被系统分配到哪处物理空间，程序本身是透明的无需去处理。但是这样还是会有第二个内存的使用效率问题。当切换进程的时候内存不足时，还是存入现有进程数据到磁盘和从磁盘加载新的程序，势必会有大量的磁盘访问。

但是由于实际中程序运行过程中只有仅仅小部分的数据会被访问，**分页**的方法可以解决第二个问题。一页多少种支持的大小由硬件确定，而由操作系统最终选择确定一页为多大。这样的话可以把常用的代码和数据加载到内存，不常用的就放在磁盘上。当进程访问到不在内存中的页时，会出现也错误的消息，系统捕获到之后会把对应的数据加载到内存中来。

计算机领域大部分问题都是通过中间层来解决。上面所说的不外如此，添加一个虚拟空间，通过映射来让 CPU 需要的时候访问实际的物理地址。把**段** 更细化为分页，这样就不需要整个进程的数据和代码都存入磁盘，或者从磁盘加载整个新的代码和数据。让常用的数据和代码在映射到内存中，不常用的映射到磁盘上。